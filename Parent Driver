/**
 * Connector WLAN Integration - Full Production
 * DD7006 Compatible - Final Corrected Version
 */
import groovy.json.JsonSlurper
import groovy.json.JsonOutput
import hubitat.helper.HexUtils
import javax.crypto.Cipher
import javax.crypto.spec.SecretKeySpec // THIS LINE WAS MISSING

metadata {
    definition(name: "Connector WLAN Integration (Full)", namespace: "connector", author: "Scubamikejax904 & Manus") {
        capability "Initialize"
        capability "Refresh"
        command "discoverDevices"
    }
    preferences {
        input name: "bridgeIp", type: "text", title: "Bridge IP", required: true
        input name: "bridgeKey", type: "text", title: "Bridge Key (16-char string from app, with hyphens)", required: true
        input name: "debugLogging", type: "bool", title: "Enable Debug Logging", defaultValue: true
    }
}

/* -------------------------------------------------- */
def installed() { initialize() }
def updated() { unschedule(); initialize() }

def initialize() {
    logDebug "Initializing..."
    state.token = null
    state.commandQueue = []
    runIn(3, "discoverDevices")
    runEvery1Minute("checkOffline")
}

/* --------------------------------------------------
   DISCOVERY
-------------------------------------------------- */
def discoverDevices() {
    def payload = [
        msgType: "GetDeviceList",
        msgID : now().toString()
    ]
    sendUdp(payload)
}

/* --------------------------------------------------
   CHILD MANAGEMENT
-------------------------------------------------- */
def createChild(mac) {
    if (getChildDevice(mac)) return
    addChildDevice(
        "connector",
        "Connector Screen Child",
        mac,
        [
            label: "Screen ${mac[-4..-1]}",
            isComponent: false
        ]
    )
    log.info "Created child ${mac}"
}

/* --------------------------------------------------
   CHILD COMMANDS
-------------------------------------------------- */
def sendChildCommand(String mac, Integer position) {
    queueCommand("doSendChildCommand", [mac: mac, position: position])
}

def sendChildStop(String mac) {
    queueCommand("doSendChildStop", [mac: mac])
}

def refreshChild(String mac) {
    queueCommand("doRefreshChild", [mac: mac])
}

/* --------------------------------------------------
   TOKEN & QUEUE MANAGEMENT
-------------------------------------------------- */
def queueCommand(String commandName, Map args) {
    logDebug "Queueing command: ${commandName} with args: ${args}"
    state.commandQueue.add([command: commandName, arguments: args])
    discoverDevices()
}

def processCommandQueue() {
    if (state.commandQueue == null || state.commandQueue.size() == 0) {
        logDebug "Command queue is empty."
        return
    }

    logDebug "Processing ${state.commandQueue.size()} command(s) from queue."
    state.commandQueue.each { cmdInfo ->
        logDebug "Executing from queue: ${cmdInfo.command}"
        this."${cmdInfo.command}"(cmdInfo.arguments)
    }
    state.commandQueue = []
}

/* --------------------------------------------------
   INTERNAL COMMAND IMPLEMENTATIONS
-------------------------------------------------- */
def doSendChildCommand(Map args) {
    def commandData = [
        targetPosition: args.position as Integer
    ]
    
    String accessToken = calculateAccessToken()
    if (!accessToken) {
        log.error "Cannot send command, failed to calculate AccessToken."
        return
    }

    def packet = [
        msgType: "WriteDevice",
        mac: args.mac,
        deviceType: "10000000",
        msgID: now().toString(),
        AccessToken: accessToken,
        data: commandData
    ]
    sendUdp(packet)
}

def doSendChildStop(Map args) {
    def commandData = [
        operation: 2
    ]
    String accessToken = calculateAccessToken()
    if (!accessToken) {
        log.error "Cannot send command, failed to calculate AccessToken."
        return
    }
    def packet = [
        msgType: "WriteDevice",
        mac: args.mac,
        deviceType: "10000000",
        msgID: now().toString(),
        AccessToken: accessToken,
        data: commandData
    ]
    sendUdp(packet)
}

def doRefreshChild(Map args) {
    sendUdp([
        msgType: "ReadDevice",
        mac: args.mac,
        deviceType: "10000000",
        msgID: now().toString(),
        AccessToken: state.token
    ])
}

/* --------------------------------------------------
   ACCESS TOKEN CALCULATION
-------------------------------------------------- */
def calculateAccessToken() {
    if (!state.token) {
        log.warn "Cannot calculate AccessToken, bridge session token is missing."
        return null
    }
    if (!bridgeKey) {
        log.warn "Cannot calculate AccessToken, Bridge Key is missing from preferences."
        return null
    }

    // Use a local variable for the toggle to avoid repeated lookups
    boolean isDebug = debugLogging
    
    if (isDebug) {
        logDebug "Calculating AccessToken with token: ${state.token} and literal key: ${bridgeKey}"
    } else {
        logDebug "Calculating AccessToken..."
    }
    
    try {
        byte[] keyBytes = bridgeKey.getBytes("UTF-8")
        
        if (keyBytes.length != 16) {
            log.error "Bridge Key in preferences MUST be exactly 16 characters long (including hyphens). Current length is ${keyBytes.length}."
            return null
        }
        
        def keySpec = new SecretKeySpec(keyBytes, "AES")
        byte[] tokenBytes = state.token.getBytes("UTF-8")
        def cipher = Cipher.getInstance("AES/ECB/PKCS5Padding")
        cipher.init(Cipher.ENCRYPT_MODE, keySpec)
        byte[] encryptedResult = cipher.doFinal(tokenBytes)
        String fullAccessToken = HexUtils.byteArrayToHexString(encryptedResult).toUpperCase()
        String finalAccessToken = fullAccessToken.take(32)
        
        if (isDebug) {
            log.info "Full calculated AccessToken: ${fullAccessToken}"
            log.warn "Truncated AccessToken being sent: ${finalAccessToken}"
        } else {
            log.info "AccessToken calculated successfully."
        }
        
        return finalAccessToken

    } catch (e) {
        log.error "FATAL: AccessToken calculation failed. Error: ${e.message}"
        return null
    }
}

/* --------------------------------------------------
   UDP SEND
-------------------------------------------------- */
def sendUdp(Map message) {
    String json = JsonOutput.toJson(message)
    
    // If debug is off, create a sanitized version of the log message
    if (!debugLogging) {
        Map sanitizedMessage = new HashMap(message)
        if (sanitizedMessage.containsKey("AccessToken")) {
            sanitizedMessage.AccessToken = "[REDACTED]"
        }
        logDebug "UDP -> ${JsonOutput.toJson(sanitizedMessage)}"
    } else {
        logDebug "UDP -> ${json}"
    }
    
    def action = new hubitat.device.HubAction(
        HexUtils.byteArrayToHexString(json.getBytes("UTF-8")),
        hubitat.device.Protocol.LAN,
        [
            type: hubitat.device.HubAction.Type.LAN_TYPE_UDPCLIENT,
            destinationAddress: "${bridgeIp}:32100",
            encoding: hubitat.device.HubAction.Encoding.HEX_STRING
        ]
    )
    sendHubCommand(action)
}
/* --------------------------------------------------
   PARSE
-------------------------------------------------- */
def parse(String description) {
    def msg = parseLanMessage(description)
    if (!msg?.payload) return
    String jsonString = new String(
        HexUtils.hexStringToByteArray(msg.payload),
        "UTF-8"
    )
    
    // If debug is off, create a sanitized version of the log message
    if (!debugLogging) {
        def json = new JsonSlurper().parseText(jsonString)
        Map sanitizedJson = new HashMap(json)
        if (sanitizedJson.containsKey("token")) {
            sanitizedJson.token = "[REDACTED]"
        }
        logDebug "UDP Received: ${JsonOutput.toJson(sanitizedJson)}"
    } else {
        logDebug "UDP Received: ${jsonString}"
    }

    def json = new JsonSlurper().parseText(jsonString)

    if (json.msgType == "GetDeviceListAck") {
        state.token = json.token
        log.info "Session token acquired/refreshed." // Removed token from this log
        processCommandQueue()
        
        json.data.each {
            if (it.deviceType == "10000000") {
                createChild(it.mac)
            }
        }
    }

    if (json.msgType == "Heartbeat") {
        log.info "Heartbeat received."
        if (state.token != json.token) {
            log.warn "Heartbeat token is different. Updating session token."
            state.token = json.token
        }
    }

    if (json.msgType == "WriteDeviceAck") {
        if (json.actionResult == "AccessToken error") {
            log.warn "AccessToken error received. Check that the Bridge Key in preferences is correct."
        } else {
            log.info "SUCCESS! Received WriteDeviceAck."
        }
    }

    if (json.msgType == "ReadDeviceAck") {
        def child = getChildDevice(json.mac)
        if (!child) return
        
        def reportData = json.data
        log.info "Status Report for ${json.mac}: ${reportData}"
        
        def pos = reportData?.currentPosition as Integer
        child.sendEvent(name: "level", value: pos)
        child.sendEvent(name: "windowShade",
                value: pos == 0 ? "open" :
                       pos == 100 ? "closed" :
                       "partially open")
        child.sendEvent(name: "lastSeen", value: new Date().toString())
    }
    
    if (json.msgType == "Report") {
        log.info "Received unsolicited status report for ${json.mac}"
    }
}
/* --------------------------------------------------
   OFFLINE DETECTION
-------------------------------------------------- */
def checkOffline() {
    getChildDevices().each { child ->
        def last = child.currentValue("lastSeen")
        if (!last) return
        def diff = (now() - Date.parse("EEE MMM dd HH:mm:ss z yyyy", last).time) / 1000
        
        // If it's been over 2 minutes AND the device isn't already marked as unknown...
        if (diff > 120 && child.currentValue("windowShade") != "unknown") {
            // MODIFICATION: Instead of changing the state, just log a warning.
            // This preserves the last known position for the user.
            log.warn "Device ${child.deviceNetworkId} has not been seen for over 2 minutes. It may be offline."
        }
    }
}

/* -------------------------------------------------- */
def refresh() {
    getChildDevices().each {
        refreshChild(it.deviceNetworkId)
    }
}

def logDebug(msg) {
    if (debugLogging) log.debug "[Connector] ${msg}"
}
